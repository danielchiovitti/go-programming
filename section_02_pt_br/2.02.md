# 2.02 Hello World

Vamos dar uma olahada como um programa Go funciona. Vamos usar o ***Go Playground*** para isso. Você precisa ter um pacote ***main*** dentro do seu programa. Dentro do pacote ***main***, você vai ter `fun main` e ***func*** é onde o seu programa roda. Ele pode fazer um monte de coisas, mas `func main` é o ponto de entrada do seu programa, e também é o ponto de saída do seu programa. Dessa forma, quando você sai de `fun main` seu programa termina.

```go
package main

import (
  "fmt"
)

func main() {
  fmt.Println("Hello, playground")
}
```
Então, você precisa de `package main` e isso é uma keyword. Como você sabe que isso é uma keyword? Você pode olhar em [Golang Spec](https://golang.org/ref/spec). Vá para especificação da linguagem, e dê uma olahada em [Lexical Elements](https://golang.org/ref/spec#Lexical_elements) onde você pode ver as [Keywords](https://golang.org/ref/spec#Keywords). Não existem muitas.
```
break        default      func         interface    select
case         defer        go           map          struct
chan         else         goto         package      switch
const        fallthrough  if           range        type
continue     for          import       return       var
```
Você não vai achar `package`, `import` e `func`

Somente reiterando, nós temos a declaração do nosso pacote, nesse caso `package main`. Estamos importando o pacote `"fmt"` da biblioteca padrão, e na nossa `func main()` estamos chamando a função `Println` do pacotr `fmt`.

Frequentemente vamos importar outros pacotes da biblioteca padrão, ou de biblioteca de terceiros. Você pode escrever o ***import*** em uma linha, ex:
```go
import "fmt"
```

Quando estamos importando vários pacotes é mais idiomático utilizar parênteses.
```go
import (
  "fmt"
)
```
Se você quiser ler a documentação do Go sobre pacotes, nesse caso o pacote `fmt`, você pode ir em [golang.org](https://golang.org/), clicar em [documents](https://golang.org/doc/) rolar a página até [package documentation](https://golang.org/pkg/), e então ir até [fmt](https://golang.org/pkg/fmt/). Você também pode ir em [godoc.org](http://godoc.org), nesse caso ir até [godoc.org/fmt](http://godoc.org/fmt). Outros exemplos são [godoc.org/het/http)(http://godoc.org/net/http), [godoc.og/html/template](http://godoc.org/html/template).
  
Então estamos olhando essa documentação [godoc.org/fmt](http://godoc.org/fmt). Se olharmos mais em baixo, podemos ver [index](https://golang.org/pkg/fmt/#pkg-index).  
OK, so we're looking at the [godoc.org/fmt](http://godoc.org/fmt) documentation. If we look down, you can see the [index](https://golang.org/pkg/fmt/#pkg-index). This is often the first place I go. Everything with a capital first letter is _exported_ from the package, or it's _visible_ from outside the package.  
  
We don't say public/private in Go. Those words come with baggage from other languages. We say Exported/Not Exported, Visible/Not Visible outside the package. If it starts with a capital letter, that means it's visible outside the package.  
  
We're using `fmt.Println` from the `fmt` package. Let's look at the documentation for [fmt.Println](http://godoc.org/fmt#Println).

```go
func Println(a ...interface{}) (n int, err error)
```
"Println formats using the default formats for its operands and writes to standard output. Spaces are always added between operands and a newline is appended. It returns the number of bytes written and any write error encountered."  
  
Generally speaking in Go, you're always going to do something with a returns, but sometimes you don't have to, and what the rule is for when you do and when you don't, I'm not totally clear. With `Println`, I've always seen it used without capturing the int and the err.  
  
If we wanted to catch the int and the err, we could say
```go
package main

import (
	"fmt"
)

func main() {
	n, err := fmt.Println("Hello, playground")
	fmt.Println(n, err)
}
```
but then you might think, now we have to do something with what is returned, so 
```go
package main

import (
	"fmt"
)

func main() {
	n, err := fmt.Println("Hello, playground")
	n2, err2 := fmt.Println(n, err)
}
```
which is probably why we don't usually see capturing the int and the err, because it could lead to an infinite loop of capturing errors.  
  
  
Another way you can get rid of things which are being returned, is you can just throw them into the void. Go is all about not wasting effort and having clean code.  
  
One of the ways to avoid _code pollution_ is to not have variables that you do not use. So in this case, if we say we have n2, and err2, but we're not using it, and try running it, it will throw an error. 

```go
package main

import (
	"fmt"
)

func main() {
	n, err := fmt.Println("Hello, playground")
	_, _ := fmt.Println(n, err)
}		
```
This says `tmp/sandbox214796246/main.go:9: no new variables on left side of :=` Which is saying we're not declaring new variables on line 9, so we can just use the equals sign (we'll learn about the short declaration in a moment), and it compiles and runs.  
```go
package main

import (
	"fmt"
)

func main() {
	n, err := fmt.Println("Hello, playground")
	_, _ = fmt.Println(n, err)
}		
```
This prints out
```
Hello, playground
18 <nil>
```
This printed out "Hello, playground" and it printed out my n, with is the number of bytes (18) and the err, which is `nil`.

To recap, from package `fmt` we have used the `Println` function. This takes a variadic parameter of any type. We'll learn about interfaces later on. When you see the triple dots and then the type, that means you can take an unlimited number of this type. This type right here `interface{}` is the empty interface. Everything implements the empty interface, so you can put as many values as you want in here and just separate them by commas, and `fmt.Println` will just print them out.  
  
So, if we wanted to, we could keep adding more variables
```go
package main

import (
	"fmt"
)

func main() {
	fmt.Println("Hello, playground", 42, "something else", true)
}
```
and it will keep printing them out.

So that is `Println` from the package `fmt`. We had some exposure to reading documentation. The main take away you should get from this video is that every program in go starts in package main, and it starts in func main. So package main needs to have func main.

func main is the entrypoint to your program, and when it exists your program is over. We use this dot notation where we have `package.Identifier` The identifier can be for a variable, a constant, or a function. Any identifier for a variable, constant or function that starts with a capital is _exported_ or visible from outside the package. `Println` starts with a capital, so we can access that. This takes a variadic parameter, which is the triple dots, and that just means it can accept any number of arguments, in this case of type of an emtpy interface `interface{}`, which can be _any_ type. We comma separate them.  
  
We will look at format printing in the next video.  

